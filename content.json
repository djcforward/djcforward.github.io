{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"java多线程","slug":"Java常用类","date":"2020-09-28T13:31:03.000Z","updated":"2020-09-28T01:47:17.205Z","comments":true,"path":"2020/09/28/Java常用类/","link":"","permalink":"http://example.com/2020/09/28/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/","excerpt":"","text":"Java常用类一、String类1、概述： * String声明为final的，不可被继承 * 实现了Serializable接口：表示字符串可以序列化，实现了Comparable即可欧，表示可以比较大小。 * String内部定义了final char[] value用于存储字符串数据 * 通过直接赋值（字面量方式），此时存储在字符串常量池中。并且字符串常量池中不会存储相同的内容。 2、String 的不可变性（相同的内容只有一个对象）2.1 说明：​ 1、当对字符串重新赋值，进行连接操作时，需要重写指定内容区域赋，不能使用原有的value进行赋值 ​ 2、当调用String的replace（）方法修改指定字符或字符串时，需要重写指定内容区域赋值，不能使用原有的value进行赋值。 ​ 代码举例： ​ 12345678910111213141516171819202122String s1 = &quot;abc&quot;;//字面量的定义方式String s2 = &quot;abc&quot;;s1 = &quot;hello&quot;;System.out.println(s1 == s2);//比较s1和s2的地址值 falseSystem.out.println(s1);//helloSystem.out.println(s2);//abcSystem.out.println(&quot;*****************&quot;);String s3 = &quot;abc&quot;;s3 += &quot;def&quot;;//这里创建了一个新的对象“abcdef”，s3指向这个地址System.out.println(s3);//abcdefSystem.out.println(s2);System.out.println(&quot;*****************&quot;);String s4 = &quot;abc&quot;;String s5 = s4.replace(&#x27;a&#x27;, &#x27;m&#x27;);//这里创建了一个新的对象“amc”，s5指向这个区域。System.out.println(s4);//abcSystem.out.println(s5);//mbc 2.3图示： 3、String实例化的不同方式3.1 方式说明 * 通过字面量的方式 * 通过new的方式 3.2代码举例1234567891011//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。String s1 = &quot;javaEE&quot;;String s2 = &quot;javaEE&quot;;//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。String s3 = new String(&quot;javaEE&quot;);String s4 = new String(&quot;javaEE&quot;);System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//falseSystem.out.println(s3 == s4);//false 3.3面试题String s = new String(“abc”);创建对象，在内存中创建了几个对象？ 两个：一个是堆空间的new结构，另一个是char[]对应的常量池的数据：“abc”. 图示： 字符串拼接方式赋值的对比4.1 说明* 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 * 只要其中一个是变量，结果就存在堆中。 * 如果凭借的结果吊用intern（）方法，返回值就在常量池中。 4.2代码举例12345678910111213141516171819202122232425262728String s1 = &quot;javaEE&quot;;String s2 = &quot;hadoop&quot;;String s3 = &quot;javaEEhadoop&quot;;String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;String s5 = s1 + &quot;hadoop&quot;;String s6 = &quot;javaEE&quot; + s2;String s7 = s1 + s2;System.out.println(s3 == s4);//trueSystem.out.println(s3 == s5);//falseSystem.out.println(s3 == s6);//falseSystem.out.println(s3 == s7);//falseSystem.out.println(s5 == s6);//falseSystem.out.println(s5 == s7);//falseSystem.out.println(s6 == s7);//falseString s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”System.out.println(s3 == s8);//true****************************String s1 = &quot;javaEEhadoop&quot;;String s2 = &quot;javaEE&quot;;String s3 = s2 + &quot;hadoop&quot;;System.out.println(s1 == s3);//falsefinal String s4 = &quot;javaEE&quot;;//s4:常量String s5 = s4 + &quot;hadoop&quot;;System.out.println(s1 == s5);//true 5.String与StringBuffer、StringBuilder之间的转换 String –&gt;StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器 StringBuffer、StringBuilder –&gt;String:①调用String构造器；②StringBuffer、StringBuilder的toString() 6 jvm中字符串常量池存储的位置* jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区） * jdk 1.7:字符串常量池存储在堆空间 * jdk 1.8:字符串常量池存储在方法区（元空间） 二、String，StringBuffer、StringBuilder三个类1、三者对比* String 不可变的字符序列，底层使用char[]存储 * StringBuffer：可变的字符序列；线程安全的，效率低；底层使用char[] 存储 * StringBuilder：可变的字符序列；线程不安全，效率高，底层使用char[]存储 2、StringBuilder与StringBuffer的内存解析​ 1234567891011121314151617以StringBuffer为例，StringBuilder也一样String str = new String();//char[] value = new char[0];String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。System.out.println(sb1.length());//sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];//问题1. System.out.println(sb2.length());//3//问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) 3、StringBuilder、Stringbuffer中的常用方法增：append(xxx)删：delete(int start,int end)改：setCharAt(int n ,char ch) / replace(int start, int end, String str)查：charAt(int n )插：insert(int offset, xxx)长度：length(); *遍历：for() + charAt() / toString() ​ 三、java比较器1.Java比较器的使用背景： Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator 2.自然排序：使用Comparable接口2.1 说明1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列3. 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。4. 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序 12345678910111213141516171819202122232425262728public class Goods implements Comparable&#123; private String name; private double price; //指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序 @Override public int compareTo(Object o) &#123;// System.out.println(&quot;**************&quot;); if(o instanceof Goods)&#123; Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price)&#123; return 1; &#125;else if(this.price &lt; goods.price)&#123; return -1; &#125;else&#123;// return 0; return -this.name.compareTo(goods.name); &#125; //方式二：// return Double.compare(this.price,goods.price); &#125;// return 0; throw new RuntimeException(&quot;传入的数据类型不一致！&quot;); &#125;// getter、setter、toString()、构造器：省略&#125; 3.定制排序：使用Comparator接口 3.1 说明1.背景：当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 123456789101112131415161718Comparator com = new Comparator() &#123; //指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName()))&#123; return -Double.compare(g1.getPrice(),g2.getPrice()); &#125;else&#123; return g1.getName().compareTo(g2.getName()); &#125; &#125; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125;&#125; 使用：Arrays.sort(goods,com);Collections.sort(coll,com);new TreeSet(com); 两种排序方式对比 Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。 Comparator接口属于临时性的比较。","categories":[],"tags":[]},{"title":"java多线程","slug":"Java多线程","date":"2020-09-27T13:31:03.000Z","updated":"2020-09-26T16:26:47.989Z","comments":true,"path":"2020/09/27/Java多线程/","link":"","permalink":"http://example.com/2020/09/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"一、常用的创建多线程的两种方式方式一：继承Thread类​ ****1、创建一个继承于Thread类的子类 ​ ****2、重写Thread类的run（）—&gt;即为此线程的操作 ​ ****3、创建Thread类的子类的对象 ​ ****4、通过此对象调用start()：①启动当前线程。②调用当前线程的run（）方法。 1234567891011121314151617181920package demon;public class Thread1 extends Thread&#123; public static int a = 2; public static void main(String[] args) &#123; Thread1 thread1 = new Thread1(); Thread1 thread2 = new Thread1(); Thread1 thread3 = new Thread1(); thread1.start(); thread2.start(); thread3.start(); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+a+&quot;执行了&quot;); &#125;&#125; ​ 注：①启动线程，必须调用start（）方法，再调run（）方法。②如果想要多个线程，必须创建多个子类对象。 方式二：实现Runnable接口​ ** 1、创建一个实现了Runnable接口的类。 ​ ** 2、实现类去实现Runnable中的抽象方法run（）。 ​ ** 3、创建实现类对象 ​ **4、将此对象作为参数传递到Thread类的构造器，创建Thread类的对象 ​ **5、通过Thread类的对象调用start（）。 12345678910111213141516public class Thread2 implements Runnable&#123; public int a = 2; public static void main(String[] args) &#123; Thread2 thread1 = new Thread2(); new Thread(thread1).start(); new Thread(thread1).start(); new Thread(thread1).start(); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+a+&quot;执行了&quot;); &#125;&#125; 两种方式比较* 开发中一般选用Runnable​ 原因：1、实现的方式突破了单继承的局限性。 ​ 2、实现的方式更适合处理多线程共享数据的情况。因为我们是把子类放在Thread类 中，每个子类都已经包含了属性值之类的。如果Thread类的话需要将这些信息设static。 *联系：Thread实现了Runnable接口*相同点;二者要想启动线程，都是调用Thread类的start()方法。二、线程的生命周期 注：sleep（），join（）不会释放锁，wait（）会释放锁 三、同步机制一、同步代码块​ synchronized(同步监视器){ ​ //需要被同步的代码 } ​ 说明：1、操作共享数据的代码。 ​ 2、同步监视器：（锁），任何一个类都可以充当锁，每个线程的锁必须是同一个。锁必须是 唯一的。 ​ 3、在实现Runnable接口的方式中，考虑用**this**充当锁，因为这个this表示的实现类，我们调用start方法时，是把这个实现类放到new Thread（）中，我们只创建了一个实现类对象。 ​ 在继承Thread类的方式中，慎用this充当锁，可以用当前类来充当。 二、同步方法​ 1、使用情况：如果操作共享数据的代码完整的声明在一个方法中，我们可以将这个方法声明为同步的。 ​ 2、总结：①同步方法本身其实也有锁，只是没有显示声明什么锁。 ​ ②非静态的同步方法，同步监视器：this ​ 静态的同步方法，同步监视器：当前类本身 三、lock锁1、synchronized与Lock的异同：​ 同：二者都可以解决线程安全问题 ​ 异：synchronized机制在执行完相应的同步代码块以后，自动的释放同步监视器 ​ Lock需要收欧东的启动同步（Lock（）），同时结束同步也需要手动的事项（unlock（）） 2、使用顺序：Lock–》同步代码块（已经进入了方法体，分配了相应资源）–》同步方法（在方法体外） 四、同步的利弊​ 同步的方式，界限了线程的安全问题—》利 ​ 操作同步代码块时，只能一个线程参与，其他线程等待，还是相当于一个单线程过程–》弊 五、同步机制的应用一、单例模式​ 12345678910111213141516171819202122懒汉式class Bank&#123; //变量随着类的加载而加载，而不着急创建对象，需要的时候在创建 private static Bank instance = null; //私有化构造器 private Bank()&#123;&#125; //提供一个公有方法去创建对象，运用同步机制，避免创建多个对象，并返回 public static Bank getInstance()&#123; if(instance=null)&#123; synchronized(Bank.class)&#123; if(instance==null)&#123;//如果没有这个就会创建多个对象 instance = new Bank(); &#125; &#125; &#125; return instance; &#125;&#125; 123456789101112131415饿汉式class Bank&#123; //变量随着类的加载而加载，直接创建对象 private static Bank instance = new Bank(); //私有化构造器 private Bank()&#123;&#125; //提供一个公有方法去创建对象，运用同步机制，避免创建多个对象，并返回 public synchronized static Bank getInstance()&#123; return instance; &#125;&#125; 二、死锁问题​ 1、理解：就是有多个线程分别占着对方需要的资源，都在等待对方释放资源，然后就gg了。 ​ 2、说明：出现死锁时，不会出现异常，提示，所有线程都处于阻塞的状态，不会体质。我们使用同步要避免死锁。下面举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread()&#123; @Override public void run() &#123; synchronized (s1)&#123; s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); try &#123; Thread.sleep(100);//增大死锁的几率，在睡眠的时候另一个线程很有可能需要 这个锁 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123; s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2)&#123; s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); try &#123; Thread.sleep(100);//增大死锁的几率，在睡眠的时候另一个线程很有可能需要 这个锁 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1)&#123; s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start();&#125; 六、线程通信（多个线程进行具有一定联系的操作）1、线程通信涉及的三个方法： wait():一旦执行此方法，当前线程就进入阻塞状态，并释放锁。 notify():一旦执行此方法，就会唤醒被wait的一个线程，如果有多个被wait就唤醒优先级最高的那个。 notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 2、说明* 1、这三个方法必须使用在同步代码块或同步方法中，这样才能达到线程通信， * 2、这三个方法的调用者必须是this或者当前类，不能像之前那样是obj，那样就不能调用这三个方法了。 3、sleep（）和wait（）异同 1、相同点：一旦执行方法，都可以使当前线程进入阻塞状态。 2、不同点: ①两个方法声明的位置不同：Thread类声明sleep（），Object类声明wait（） ​ ②调用的要求不同：sleep（）可以在任何需要的场景下调用，wait（）必须使用在同步代码块中。 ​ ③sleep（）不会释放锁，wait（）会释放锁 4、释放与不释放锁的操作​ 1、释放锁的操作 当前线程同步代码块，同步方法结束或遇到break，return结束 出现了Error或者Exception，导致异常结束 当前线程在同步代码块、方法中执行了线程对象的wait（）方法，线程暂停，释放锁。 ​ 2、不会释放所得操作 * 当前线程调用Thread.slepp() Thread.yield()方法，暂停当前线程的执行 * 线程执行同步代码块时，其他线程调用了该线程的suspend（）方法将该线程挂起，该线程不会释放锁。（应尽量避免使用suspend（）和resume（）来控制线程）。 5、线程通信的具体实例（生产者消费者模式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.atguigu.java2;/** * 线程通信的应用：经典例题：生产者/消费者问题 * * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品， * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员 * 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品 * 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 * * 分析： * 1. 是否是多线程问题？是，生产者线程，消费者线程 * 2. 是否有共享数据？是，店员（或产品） * 3. 如何解决线程的安全问题？同步机制,有三种方法 * 4. 是否涉及线程的通信？是 * * @author shkstart * @create 2019-02-15 下午 4:48 */class Clerk&#123; private int productCount = 0; //生产产品 public synchronized void produceProduct() &#123; if(productCount &lt; 20)&#123; productCount++; System.out.println(Thread.currentThread().getName() + &quot;:开始生产第&quot; + productCount + &quot;个产品&quot;); notify(); &#125;else&#123; //等待 try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //消费产品 public synchronized void consumeProduct() &#123; if(productCount &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:开始消费第&quot; + productCount + &quot;个产品&quot;); productCount--; notify(); &#125;else&#123; //等待 try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Producer extends Thread&#123;//生产者 private Clerk clerk; public Producer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(getName() + &quot;:开始生产产品.....&quot;); while(true)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.produceProduct(); &#125; &#125;&#125;class Consumer extends Thread&#123;//消费者 private Clerk clerk; public Consumer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(getName() + &quot;:开始消费产品.....&quot;); while(true)&#123; try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.consumeProduct(); &#125; &#125;&#125;public class ProductTest &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(&quot;生产者1&quot;); Consumer c1 = new Consumer(clerk); c1.setName(&quot;消费者1&quot;); Consumer c2 = new Consumer(clerk); c2.setName(&quot;消费者2&quot;); p1.start(); c1.start(); c2.start(); &#125;&#125;","categories":[],"tags":[]},{"title":"java基础之面向对象（三大特征：封装性，继承性、多态）","slug":"java基础之面向对象（三大特征：封装性，继承性、多态）","date":"2020-09-23T13:31:03.000Z","updated":"2020-09-24T04:46:49.613Z","comments":true,"path":"2020/09/23/java基础之面向对象（三大特征：封装性，继承性、多态）/","link":"","permalink":"http://example.com/2020/09/23/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%8C%E7%BB%A7%E6%89%BF%E6%80%A7%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%89/","excerpt":"","text":"一、多态：​ 1、理解：一个事物可以有多种形态，例如人，分为男人，女人。 男人，女人都继承了人这个特性。 ​ 2、使用的总结：（适用前提：继承关系，重写方法） ​ 2.1：编译看左边；运行看右边。编译期时，只能调用父类的已有方法，但是实际在运行时，运行的是我们重写的父类的方法。 ​ 2.2：对象的多态只用于方法，不能用于属性。 ​ 2.3：想用子类的属性和方法时，使用向下转型。因为我们声明的时候是把子类转换成父类，所以我们只能用父类已有的，但是内存中实际已经加载了子类特有的方法和属性。只要我们通过强制转换成原来的类型即可。 12Person p = new man();//这里只能用父类的属性、方法man m = (man)p;//向下转型，可以用子类方法 ​ 2.3.1: ClassCastException的异常，如果我们向下转型的时候，之前声明的子类是man（），但是向下转型时我们转成women（），这是不被允许的，要求向下转型的类型是之前那个类（必须是之前的这个类，这个类的子类也不行）。 多态的面试题： 3.1 谈谈你对多态性的理解？① 实现代码的通用性。② Object类中定义的public boolean equals(Object obj){ } JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）3.2 多态是编译时行为还是运行时行为？ ​ 运行时行为。证明：利用随机数产生不同的对象（这几个类继承同一个父类）,每次随机出来的对象是不一样的，说明运行时才会得到具体是哪个对象。 二、static关键字（静态的）​ static是与类绑定的，早于对象创建。 1、通常修饰的结构：属性、方法、代码块、内部类 2、修饰属性时（静态变量） ​ 当我们创建多个同一个类的对象时，多个对象共享一个static变量，如果其中一个对象修改这个static变量，其他对象所获得的值也会改变。 ​ 其他说明： ​ 2.1 静态变量随着类的加载。可以通过“类.静态变量”的方法进行调用。 ​ 2.2 类只会加载一次，所以静态变量也只会存在一份，存在方法区的静态域中。（方法区包括：类的加载信息，静态域、常量池） 3、static修饰方法 ​ 1 随着类的加载而加载，调用方法：“类.静态方法”的方式调用，不需要创建对象 ​ 2 静态方法只能调用静态的。非静态方法既可以调用静态的，也可以调用非静态的。 三、代码块（一般用于初始化类、对象的信息）​ 1 静态代码块（static修饰） &gt;内部可以输出语句。 &gt; &gt;随着类的加载而加载，只能执行一次，用于初始化类的信息。 &gt; &gt;如果一个类定义了多个静态代码块，则按照声明的先后顺序执行。 &gt; &gt;静态只能调用静态。 ​ 2 非静态代码块 内部可以输出语句。 随着对象的创建而创建，每创建一个对象就执行一次非静态代码块，可以对对象的属性进行初始化 如果一个类定义了多个非静态代码块，则按照声明的先后顺序执行。 非静态可以调用静态和非静态。 四、abstract关键字（抽象的，修饰类，方法）​ 1、修饰类 &gt;此类不能被实例化，必须要有构造器，以供于子类实例化 &gt; &gt;一般都会有子类去继承一个抽象类，让子类对象实例化去操作 ​ 2、修饰方法 &gt;&gt; 如果修饰方法，只是声明了这个方法，不能有方法体 &gt; &gt;&gt; 如果子类重写了父类的所有抽象方法，此子类可以实例化，没有重写所有不可以实例化 ​ 3、注意点 包含抽象方法的类一定是抽象类，但是抽象类不一定所有都是抽象方法，可以没有抽象方法。 五、内部类1、分类：成员内部类(静态、非静态)，局部内部类（方法内、代码块内、构造器内）2、成员内部类：2.1 作为外部类的成员 可以调用外部类的结构 可以被static修饰 可以被4中不同的权限修饰符修饰 2.2 作为一个类 可以定义属性、方法、构造器等 可以被继承，final，abstract修饰 2.3 创建成员内部类的对象（静态的、非静态的） 创建静态的Dog内部类的实例（静态的成员内部类） 1Person.Dog dog = new Person.Dog(); 创建非静态的的成员内部类 12Person p = new Person();Person.Bird brid = p.new Bird(); 2.4 调用外部类的结构123456789101112131415class Person&#123; String name = &quot;小明&quot;;public void eat()&#123;&#125;//非静态成员内部类 class Bird&#123; String name = &quot;杜鹃&quot;; public void display(String name)&#123; System.out.println(name);//方法的形参 System.out.println(this.name);//内部类的属性 System.out.println(Person.this.name);//外部类的属性 //Person.this.eat(); &#125; &#125;&#125; 3、局部内部类局部内部类的使用（通常用匿名内部类，即为方式二） 123456789101112131415161718192021222324252627//返回一个实现了Comparable接口的类的对象 public Comparable getComparable()&#123; //创建一个实现了Comparable接口的类:局部内部类 //方式一：// class MyComparable implements Comparable&#123;//// @Override// public int compareTo(Object o) &#123;// return 0;// &#125;// // &#125;// // return new MyComparable(); //方式二： return new Comparable()&#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125;; &#125; ​ 注意点：在一个方法中有局部变量是，也有局部内部类，如果这个局部内部类想用方法中的局部变量，可以直接用（其实这个变量是final的，jdk8及以后省略了，以前的必须要显示声明）。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-09-23T13:17:47.334Z","updated":"2020-09-23T13:17:47.334Z","comments":true,"path":"2020/09/23/hello-world/","link":"","permalink":"http://example.com/2020/09/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}